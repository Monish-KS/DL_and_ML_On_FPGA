-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\DNN_Simulation_Model\DNN_Subsystem.vhd
-- Created: 2024-08-06 14:39:05
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 0.1
-- Target subsystem base rate: 0.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: DNN_Subsystem
-- Source Path: DNN_Simulation_Model/DNN_Subsystem
-- Hierarchy Level: 0
-- Model version: 1.24
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.DNN_Subsystem_pkg.ALL;

ENTITY DNN_Subsystem IS
  PORT( X                                 :   IN    vector_of_std_logic_vector12(0 TO 7);  -- sfix12_En11 [8]
        yprd                              :   OUT   std_logic  -- ufix1
        );
END DNN_Subsystem;


ARCHITECTURE rtl OF DNN_Subsystem IS

  -- Component Declarations
  COMPONENT Hidden_Layer1
    PORT( Bias                            :   IN    vector_of_std_logic_vector5(0 TO 2);  -- sfix5_En2 [3]
          Weight                          :   IN    matrix_of_std_logic_vector5(0 TO 2, 0 TO 7);  -- sfix5_En2 [3x8]
          X                               :   IN    vector_of_std_logic_vector12(0 TO 7);  -- sfix12_En11 [8]
          ytan                            :   OUT   vector_of_std_logic_vector16(0 TO 2)  -- sfix16_En14 [3]
          );
  END COMPONENT;

  COMPONENT Hidden_Layer2
    PORT( Bias                            :   IN    vector_of_std_logic_vector5(0 TO 3);  -- sfix5_En2 [4]
          Weight                          :   IN    matrix_of_std_logic_vector5(0 TO 3, 0 TO 2);  -- sfix5_En2 [4x3]
          X                               :   IN    vector_of_std_logic_vector16(0 TO 2);  -- sfix16_En14 [3]
          ytan                            :   OUT   vector_of_std_logic_vector16(0 TO 3)  -- sfix16_En14 [4]
          );
  END COMPONENT;

  COMPONENT OutputLayer
    PORT( Bias                            :   IN    std_logic_vector(4 DOWNTO 0);  -- sfix5_En3
          Weight                          :   IN    vector_of_std_logic_vector6(0 TO 3);  -- sfix6_En2 [4]
          X                               :   IN    vector_of_std_logic_vector16(0 TO 3);  -- sfix16_En14 [4]
          ytan                            :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En14
          );
  END COMPONENT;

  COMPONENT BinaryPrediction
    PORT( u                               :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          Thresh                          :   IN    std_logic;  -- ufix1_En1
          yprd                            :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Hidden_Layer1
    USE ENTITY work.Hidden_Layer1(rtl);

  FOR ALL : Hidden_Layer2
    USE ENTITY work.Hidden_Layer2(rtl);

  FOR ALL : OutputLayer
    USE ENTITY work.OutputLayer(rtl);

  FOR ALL : BinaryPrediction
    USE ENTITY work.BinaryPrediction(rtl);

  -- Signals
  SIGNAL b5_out1                          : signed(4 DOWNTO 0);  -- sfix5_En3
  SIGNAL W3_out1                          : vector_of_signed6(0 TO 3);  -- sfix6_En2 [4]
  SIGNAL W3_out1_1                        : vector_of_std_logic_vector6(0 TO 3);  -- ufix6 [4]
  SIGNAL b2_out1                          : vector_of_signed5(0 TO 3);  -- sfix5_En2 [4]
  SIGNAL b2_out1_1                        : vector_of_std_logic_vector5(0 TO 3);  -- ufix5 [4]
  SIGNAL c20_W2_out1                      : vector_of_signed5(0 TO 11);  -- sfix5_En2 [12]
  SIGNAL W2_out1                          : matrix_of_signed5(0 TO 3, 0 TO 2);  -- sfix5_En2 [4x3]
  SIGNAL W2_out1_1                        : matrix_of_std_logic_vector5(0 TO 3, 0 TO 2);  -- ufix5 [4x3]
  SIGNAL b1_out1                          : vector_of_signed5(0 TO 2);  -- sfix5_En2 [3]
  SIGNAL b1_out1_1                        : vector_of_std_logic_vector5(0 TO 2);  -- ufix5 [3]
  SIGNAL c18_W1_out1                      : vector_of_signed5(0 TO 23);  -- sfix5_En2 [24]
  SIGNAL W1_out1                          : matrix_of_signed5(0 TO 2, 0 TO 7);  -- sfix5_En2 [3x8]
  SIGNAL W1_out1_1                        : matrix_of_std_logic_vector5(0 TO 2, 0 TO 7);  -- ufix5 [3x8]
  SIGNAL ytan                             : vector_of_std_logic_vector16(0 TO 2);  -- ufix16 [3]
  SIGNAL ytan_1                           : vector_of_std_logic_vector16(0 TO 3);  -- ufix16 [4]
  SIGNAL ytan_2                           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Threshold_out1                   : std_logic;  -- ufix1_En1

BEGIN
  u_Hidden_Layer1 : Hidden_Layer1
    PORT MAP( Bias => b1_out1_1,  -- sfix5_En2 [3]
              Weight => W1_out1_1,  -- sfix5_En2 [3x8]
              X => X,  -- sfix12_En11 [8]
              ytan => ytan  -- sfix16_En14 [3]
              );

  u_Hidden_Layer2 : Hidden_Layer2
    PORT MAP( Bias => b2_out1_1,  -- sfix5_En2 [4]
              Weight => W2_out1_1,  -- sfix5_En2 [4x3]
              X => ytan,  -- sfix16_En14 [3]
              ytan => ytan_1  -- sfix16_En14 [4]
              );

  u_OutputLayer : OutputLayer
    PORT MAP( Bias => std_logic_vector(b5_out1),  -- sfix5_En3
              Weight => W3_out1_1,  -- sfix6_En2 [4]
              X => ytan_1,  -- sfix16_En14 [4]
              ytan => ytan_2  -- sfix16_En14
              );

  u_BinaryPrediction : BinaryPrediction
    PORT MAP( u => ytan_2,  -- sfix16_En14
              Thresh => Threshold_out1,  -- ufix1_En1
              yprd => yprd  -- ufix1
              );

  b5_out1 <= to_signed(-16#0C#, 5);

  W3_out1(0) <= to_signed(-16#03#, 6);
  W3_out1(1) <= to_signed(-16#03#, 6);
  W3_out1(2) <= to_signed(-16#09#, 6);
  W3_out1(3) <= to_signed(-16#11#, 6);

  outputgen6: FOR k IN 0 TO 3 GENERATE
    W3_out1_1(k) <= std_logic_vector(W3_out1(k));
  END GENERATE;

  b2_out1(0) <= to_signed(-16#09#, 5);
  b2_out1(1) <= to_signed(-16#03#, 5);
  b2_out1(2) <= to_signed(16#04#, 5);
  b2_out1(3) <= to_signed(16#08#, 5);

  outputgen5: FOR k IN 0 TO 3 GENERATE
    b2_out1_1(k) <= std_logic_vector(b2_out1(k));
  END GENERATE;

  c20_W2_out1(0) <= to_signed(16#07#, 5);
  c20_W2_out1(1) <= to_signed(16#02#, 5);
  c20_W2_out1(2) <= to_signed(16#04#, 5);
  c20_W2_out1(3) <= to_signed(16#09#, 5);
  c20_W2_out1(4) <= to_signed(-16#03#, 5);
  c20_W2_out1(5) <= to_signed(-16#01#, 5);
  c20_W2_out1(6) <= to_signed(-16#02#, 5);
  c20_W2_out1(7) <= to_signed(16#06#, 5);
  c20_W2_out1(8) <= to_signed(16#05#, 5);
  c20_W2_out1(9) <= to_signed(-16#09#, 5);
  c20_W2_out1(10) <= to_signed(-16#08#, 5);
  c20_W2_out1(11) <= to_signed(16#02#, 5);

  W2_out1_gen1: FOR d1 IN 0 TO 2 GENERATE
    W2_out1_gen: FOR d0 IN 0 TO 3 GENERATE
      W2_out1(d0, d1) <= c20_W2_out1(d0 + (d1 * 4));
    END GENERATE;
  END GENERATE;

  outputgen3: FOR k IN 0 TO 3 GENERATE
    outputgen4: FOR k1 IN 0 TO 2 GENERATE
      W2_out1_1(k, k1) <= std_logic_vector(W2_out1(k, k1));
    END GENERATE;
  END GENERATE;

  b1_out1(0) <= to_signed(-16#07#, 5);
  b1_out1(1) <= to_signed(16#02#, 5);
  b1_out1(2) <= to_signed(-16#09#, 5);

  outputgen2: FOR k IN 0 TO 2 GENERATE
    b1_out1_1(k) <= std_logic_vector(b1_out1(k));
  END GENERATE;

  c18_W1_out1(0) <= to_signed(-16#03#, 5);
  c18_W1_out1(1) <= to_signed(-16#02#, 5);
  c18_W1_out1(2) <= to_signed(-16#01#, 5);
  c18_W1_out1(3) <= to_signed(-16#0A#, 5);
  c18_W1_out1(4) <= to_signed(-16#06#, 5);
  c18_W1_out1(5) <= to_signed(-16#05#, 5);
  c18_W1_out1(6) <= to_signed(16#06#, 5);
  c18_W1_out1(7) <= to_signed(16#01#, 5);
  c18_W1_out1(8) <= to_signed(-16#02#, 5);
  c18_W1_out1(9) <= to_signed(16#02#, 5);
  c18_W1_out1(10) <= to_signed(-16#01#, 5);
  c18_W1_out1(11) <= to_signed(16#02#, 5);
  c18_W1_out1(12) <= to_signed(16#01#, 5);
  c18_W1_out1(13) <= to_signed(16#00#, 5);
  c18_W1_out1(14) <= to_signed(16#01#, 5);
  c18_W1_out1(15) <= to_signed(-16#02#, 5);
  c18_W1_out1(16) <= to_signed(-16#05#, 5);
  c18_W1_out1(17) <= to_signed(16#00#, 5);
  c18_W1_out1(18) <= to_signed(-16#04#, 5);
  c18_W1_out1(19) <= to_signed(16#00#, 5);
  c18_W1_out1(20) <= to_signed(16#01#, 5);
  c18_W1_out1(21) <= to_signed(-16#07#, 5);
  c18_W1_out1(22) <= to_signed(16#03#, 5);
  c18_W1_out1(23) <= to_signed(-16#01#, 5);

  W1_out1_gen1: FOR d1 IN 0 TO 7 GENERATE
    W1_out1_gen: FOR d0 IN 0 TO 2 GENERATE
      W1_out1(d0, d1) <= c18_W1_out1(d0 + (d1 * 3));
    END GENERATE;
  END GENERATE;

  outputgen: FOR k IN 0 TO 2 GENERATE
    outputgen1: FOR k1 IN 0 TO 7 GENERATE
      W1_out1_1(k, k1) <= std_logic_vector(W1_out1(k, k1));
    END GENERATE;
  END GENERATE;

  Threshold_out1 <= '1';

END rtl;

