-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\DNN_Simulation_Model\Hidden_Layer2.vhd
-- Created: 2024-08-06 14:39:05
-- 
-- Generated by MATLAB 24.1, HDL Coder 24.1, and Simulink 24.1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Hidden_Layer2
-- Source Path: DNN_Simulation_Model/DNN_Subsystem/Hidden_Layer2
-- Hierarchy Level: 1
-- Model version: 1.24
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.DNN_Subsystem_pkg.ALL;

ENTITY Hidden_Layer2 IS
  PORT( Bias                              :   IN    vector_of_std_logic_vector5(0 TO 3);  -- sfix5_En2 [4]
        Weight                            :   IN    matrix_of_std_logic_vector5(0 TO 3, 0 TO 2);  -- sfix5_En2 [4x3]
        X                                 :   IN    vector_of_std_logic_vector16(0 TO 2);  -- sfix16_En14 [3]
        ytan                              :   OUT   vector_of_std_logic_vector16(0 TO 3)  -- sfix16_En14 [4]
        );
END Hidden_Layer2;


ARCHITECTURE rtl OF Hidden_Layer2 IS

  -- Signals
  SIGNAL Bias_signed                      : vector_of_signed5(0 TO 3);  -- sfix5_En2 [4]
  SIGNAL Weight_signed                    : matrix_of_signed5(0 TO 3, 0 TO 2);  -- sfix5_En2 [4x3]
  SIGNAL X_signed                         : vector_of_signed16(0 TO 2);  -- sfix16_En14 [3]
  SIGNAL ytan_tmp                         : vector_of_signed16(0 TO 3);  -- sfix16_En14 [4]

BEGIN
  outputgen4: FOR k1 IN 0 TO 3 GENERATE
    Bias_signed(k1) <= signed(Bias(k1));
  END GENERATE;

  outputgen2: FOR k1 IN 0 TO 3 GENERATE
    outputgen3: FOR k2 IN 0 TO 2 GENERATE
      Weight_signed(k1, k2) <= signed(Weight(k1, k2));
    END GENERATE;
  END GENERATE;

  outputgen1: FOR k1 IN 0 TO 2 GENERATE
    X_signed(k1) <= signed(X(k1));
  END GENERATE;

  Hidden_Layer2_1_output : PROCESS (Bias_signed, Weight_signed, X_signed)
    VARIABLE y : signed(15 DOWNTO 0);
    VARIABLE prodAB : signed(20 DOWNTO 0);
    VARIABLE c : signed(22 DOWNTO 0);
    VARIABLE slice_temp : signed(15 DOWNTO 0);
    VARIABLE add_cast : vector_of_signed16(0 TO 3);
    VARIABLE add_cast_0 : vector_of_signed17(0 TO 3);
    VARIABLE add_cast_1 : vector_of_signed17(0 TO 3);
    VARIABLE add_temp : vector_of_signed17(0 TO 3);
    VARIABLE add_cast_2 : vector_of_signed24(0 TO 2);
    VARIABLE add_cast_3 : vector_of_signed24(0 TO 2);
    VARIABLE add_temp_0 : vector_of_signed24(0 TO 2);
    VARIABLE mul_temp : vector_of_signed32(0 TO 3);
    VARIABLE add_cast_4 : vector_of_signed33(0 TO 3);
    VARIABLE add_temp_1 : vector_of_signed33(0 TO 3);
    VARIABLE mul_temp_0 : vector_of_signed32(0 TO 3);
    VARIABLE mul_temp_1 : vector_of_signed32(0 TO 3);
    VARIABLE add_cast_5 : vector_of_signed33(0 TO 3);
    VARIABLE add_temp_2 : vector_of_signed33(0 TO 3);
  BEGIN
    c := to_signed(16#000000#, 23);
    y := to_signed(16#0000#, 16);
    prodAB := to_signed(16#000000#, 21);
    slice_temp := to_signed(16#0000#, 16);

    FOR k IN 0 TO 3 LOOP
      c := to_signed(16#000000#, 23);

      FOR k_0 IN 0 TO 2 LOOP
        prodAB := Weight_signed(k, k_0) * X_signed(k_0);
        add_cast_2(k_0) := resize(c, 24);
        add_cast_3(k_0) := resize(prodAB, 24);
        add_temp_0(k_0) := add_cast_2(k_0) + add_cast_3(k_0);
        IF (add_temp_0(k_0)(23) = '0') AND (add_temp_0(k_0)(22) /= '0') THEN 
          c := "01111111111111111111111";
        ELSIF (add_temp_0(k_0)(23) = '1') AND (add_temp_0(k_0)(22) /= '1') THEN 
          c := "10000000000000000000000";
        ELSE 
          c := add_temp_0(k_0)(22 DOWNTO 0);
        END IF;
      END LOOP;

      IF ((c(22) = '0') AND (c(21) /= '0')) OR ((c(22) = '0') AND (c(21 DOWNTO 6) = X"7FFF")) THEN 
        add_cast(k) := X"7FFF";
      ELSIF (c(22) = '1') AND (c(21) /= '1') THEN 
        add_cast(k) := X"8000";
      ELSE 
        add_cast(k) := c(21 DOWNTO 6) + ('0' & c(5));
      END IF;
      add_cast_0(k) := resize(add_cast(k), 17);
      add_cast_1(k) := resize(Bias_signed(k) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 17);
      add_temp(k) := add_cast_0(k) + add_cast_1(k);
      IF (add_temp(k)(16) = '0') AND (add_temp(k)(15) /= '0') THEN 
        slice_temp := X"7FFF";
      ELSIF (add_temp(k)(16) = '1') AND (add_temp(k)(15) /= '1') THEN 
        slice_temp := X"8000";
      ELSE 
        slice_temp := add_temp(k)(15 DOWNTO 0);
      END IF;
      -- Word Length
      -- Fractional Length
      -- Slopes and Offsets
      -- Piecewise Linear Approximation of Tanh Function
      IF slice_temp < to_signed(-16#0800#, 16) THEN 
        y := to_signed(-16#0400#, 16);
      ELSIF slice_temp < to_signed(-16#0466#, 16) THEN 
        mul_temp(k) := to_signed(16#00B8#, 16) * slice_temp;
        add_cast_4(k) := resize(mul_temp(k), 33);
        add_temp_1(k) := add_cast_4(k) + to_signed(-754688, 33);
        y := add_temp_1(k)(25 DOWNTO 10);
      ELSIF (slice_temp >= to_signed(-16#0466#, 16)) AND (slice_temp <= to_signed(16#0466#, 16)) THEN 
        mul_temp_0(k) := to_signed(16#0348#, 16) * slice_temp;
        y := mul_temp_0(k)(25 DOWNTO 10);
      ELSIF slice_temp <= to_signed(16#0800#, 16) THEN 
        mul_temp_1(k) := to_signed(16#00B8#, 16) * slice_temp;
        add_cast_5(k) := resize(mul_temp_1(k), 33);
        add_temp_2(k) := add_cast_5(k) + to_signed(754688, 33);
        y := add_temp_2(k)(25 DOWNTO 10);
      ELSE 
        y := to_signed(16#0400#, 16);
      END IF;
      IF (y(15) = '0') AND (y(14 DOWNTO 11) /= "0000") THEN 
        ytan_tmp(k) <= X"7FFF";
      ELSIF (y(15) = '1') AND (y(14 DOWNTO 11) /= "1111") THEN 
        ytan_tmp(k) <= X"8000";
      ELSE 
        ytan_tmp(k) <= y(11 DOWNTO 0) & '0' & '0' & '0' & '0';
      END IF;
    END LOOP;

  END PROCESS Hidden_Layer2_1_output;


  outputgen: FOR k1 IN 0 TO 3 GENERATE
    ytan(k1) <= std_logic_vector(ytan_tmp(k1));
  END GENERATE;

END rtl;

